% This script loads mat files containing the harmonic Green's function for
% a transverse isotropic medium computed with the script
% "compGreeenFuncsMusclePulse.m". Each function is weighted with the 
% value of the signal's Fourier transform at the corresponding frequency. 
% The displacement generated by the applied signal is obtained
% form the inverse Fourier transform of the sum of all weighted Green's
% functions.
%
% Author: Fabrice Prieur
% Creation date: 04 june 2018
% Copyright: University of Oslo

clear all
% Definition of the signal and of the frequencies of interest. This part is
% the same as in the script "compGreeenFuncsMusclePulse.m"
tsignal=480e-6;
tsig=6e-3;
fs=200e3;
t=(0:1/fs:tsig);
freq=(0:length(t)-1)/length(t)*fs;
ix=find(t<=tsignal);
signal=zeros(1,length(t));
signal(ix)=hann(length(ix)).';
specsignal=fft(signal);
specRed=specsignal(1:25); % Reduced frequency spectrum
specRecon=0*specsignal;
specRecon(1:length(specRed))=specRed;
specRecon(end-length(specRed)+2:end)=conj(fliplr(specRed(2:end)));
signalRecon=real(ifft(specRecon)); % Reconstructed signal
% amplitude has to be adjusted since only part of the spectrum is taken
% into account
coef=max(signal)/max(signalRecon);
signalRecon=signalRecon*coef;

%% Plots
figure('color','w','Position',[251,378,829,420]);
subplot('position',[0.041,0.11,0.443,0.815]);
plot(t*1e6,signal,'b','linewidth',2);xlim([0 2000]);
xlabel('t [\mus]','fontweight','bold','fontsize',11);
title('push pulse');grid
subplot('position',[0.544,0.11,0.427,0.815]);
plot(freq,abs(specsignal),'b','linewidth',2);xlim([0 10000]);
hold on;plot(freq(1:length(specRed)),abs(specRed),'ro','linewidth',2);
legend({'signal spectrum','truncated spectrum'},'fontweight','bold','fontsize',11);
title('push pulse frequency spectrum');grid
xlabel('f [Hz]','fontweight','bold','fontsize',11);


%%
for i=1:length(specRed)
    fname=['Data\GreenFunctions_',int2str(i)];
    load(fname);
    omega=2*pi*freq(i);

    % Displacements only due to SV and SH waves
    xdispSV_Fx=squeeze(GrCoef1(:,:,2,1)+GsCoef1(:,:,2,1));
    xdispSH_Fx=squeeze(GrCoef1(:,:,3,1)+GsCoef1(:,:,3,1));
    zdispSV_Fx=squeeze(GrCoef1(:,:,2,2)+GsCoef1(:,:,2,2));
    zdispSH_Fx=squeeze(GrCoef1(:,:,3,2)+GsCoef1(:,:,3,2));
    % No z displacement due to SV

    xdispSV_Fz=squeeze(GrCoef3(:,:,2,1)+GsCoef3(:,:,2,1));
    xdispSH_Fz=squeeze(GrCoef3(:,:,3,1)+GsCoef3(:,:,3,1));
    zdispSV_Fz=squeeze(GrCoef3(:,:,2,2)+GsCoef3(:,:,2,2));
    % No z displacement due to SV
    if i==1 % do not need to take into account contribution at f=0
        Gx_Fx=zeros(size(GrCoef1,1),size(GrCoef1,2),length(signal));
        Gz_Fx=zeros(size(GrCoef1,1),size(GrCoef1,2),length(signal));
        Gx_Fz=zeros(size(GrCoef1,1),size(GrCoef1,2),length(signal));
        Gz_Fz=zeros(size(GrCoef1,1),size(GrCoef1,2),length(signal));
    else
        Gx_Fx(:,:,end-i+2)=squeeze(GrCoef1(:,:,2,1)+GsCoef1(:,:,2,1)+GrCoef1(:,:,3,1)+GsCoef1(:,:,3,1))*conj(specRed(i))*coef;    
        Gz_Fx(:,:,end-i+2)=squeeze(GrCoef1(:,:,2,2)+GsCoef1(:,:,2,2))*conj(specRed(i))*coef;
        Gx_Fz(:,:,end-i+2)=squeeze(GrCoef3(:,:,2,1)+GsCoef3(:,:,2,1)+GrCoef3(:,:,3,1)+GsCoef3(:,:,3,1))*conj(specRed(i))*coef;    
        Gz_Fz(:,:,end-i+2)=squeeze(GrCoef3(:,:,2,2)+GsCoef3(:,:,2,2))*conj(specRed(i))*coef;
    end

end


dispx_Fx=real(ifft(Gx_Fx,[],3));
dispz_Fx=real(ifft(Gz_Fx,[],3));
dispx_Fz=real(ifft(Gx_Fz,[],3));
dispz_Fz=real(ifft(Gz_Fz,[],3));

% displacements are computed only on one quadrant. Mirror it in both dir.
dispx_Fx=vertcat(flipud(dispx_Fx),dispx_Fx);
dispx_Fx=horzcat(fliplr(dispx_Fx),dispx_Fx);
dispz_Fx=vertcat(flipud(dispz_Fx),dispz_Fx);
dispz_Fx=horzcat(fliplr(dispz_Fx),dispz_Fx);
dispx_Fz=vertcat(flipud(dispx_Fz),dispx_Fz);
dispx_Fz=horzcat(fliplr(dispx_Fz),dispx_Fz);
dispz_Fz=vertcat(flipud(dispz_Fz),dispz_Fz);
dispz_Fz=horzcat(fliplr(dispz_Fz),dispz_Fz);

xx=horzcat(-fliplr(x),x);
zz=horzcat(-fliplr(z),z);

[X,Z]=meshgrid(xx,zz);

% Interpolation on a uniform grid to be able to convovle
dx=min(diff(x));
dz=min(diff(z));
xint=(-15e-3:dx:15e-3);
zint=(-15e-3:dz:15e-3);
[Xint,Zint]=meshgrid(xint,zint);

% keep only half of the signal length to speed up convolution computation
xdispShearFxInt=zeros(size(Xint,1),size(Xint,2),round(size(dispx_Fx,3)/2));
tred=t(1:size(xdispShearFxInt,3));
zdispShearFxInt=xdispShearFxInt;
xdispShearFzInt=xdispShearFxInt;
zdispShearFzInt=xdispShearFxInt;

% Set the very high values at the origin to 0. It's expected that the
% Green's function diverges at the source location.
for i=1:size(xdispShearFxInt,3)
    
    m=dispx_Fx(:,:,i);m(abs(m)>1)=0;
    xdispShearFxInt(:,:,i)=interp2(X,Z,m,Xint,Zint);    
    m=dispz_Fx(:,:,i);m(abs(m)>1)=0;
    zdispShearFxInt(:,:,i)=interp2(X,Z,m,Xint,Zint);

    m=dispx_Fz(:,:,i);m(abs(m)>1)=0;
    xdispShearFzInt(:,:,i)=interp2(X,Z,m,Xint,Zint);
    m=dispz_Fz(:,:,i);m(abs(m)>1)=0;
    zdispShearFzInt(:,:,i)=interp2(X,Z,m,Xint,Zint);
end

save('Data\displGridinPulse.mat','xint','zint','Xint','Zint','zdispShearFxInt','xdispShearFxInt','xdispShearFzInt','zdispShearFzInt','tred');

%% Plot
ds=2;
figure('color','w','position',[723,364,1114,420])
for i=1:40:size(dispx_Fx,3)
    subplot(1,2,1);
    imagesc(xx*1e3,zz*1e3,squeeze(sqrt(dispx_Fx(:,:,i).^2+dispz_Fx(:,:,i).^2)));caxis([-1 1]*1e-2);hold on;
%     quiver(xax(1:ds:end)*1e3,zax(1:ds:end)*1e3,squeeze(dispx_Fx(1:ds:end,1:ds:end,i)),squeeze(dispz_Fx(1:ds:end,1:ds:end,i)),'k');
    title(['disp from Fx, t = ',num2str(t(i)*1e3,'%.2f'),' ms']);
    colormap jet;axis('image');colorbar
    xlabel('x [mm]');ylabel('z [mm]')
    xlim([min(xx) max(xx)]*1e3);ylim([min(zz) max(zz)]*1e3);
    subplot(1,2,2);
    imagesc(xx*1e3,zz*1e3,squeeze(sqrt(dispx_Fz(:,:,i).^2+dispz_Fz(:,:,i).^2)));caxis([-1 1]*1e-3);hold on;
%     quiver(xax(1:ds:end)*1e3,zax(1:ds:end)*1e3,squeeze(dispx_Fz(1:ds:end,1:ds:end,i)),squeeze(dispz_Fz(1:ds:end,1:ds:end,i)),'k');
    title(['disp from Fz, t = ',num2str(t(i)*1e3,'%.2f'),' ms']);
    xlabel('x [mm]');ylabel('z [mm]');axis('image');colorbar
    xlim([min(xx) max(xx)]*1e3);ylim([min(zz) max(zz)]*1e3);
    pause(0.01);
end

